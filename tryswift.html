<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<title>Try Swift</title>

<!-- <script src="js/script.js"></script> -->
<link rel="stylesheet" type="text/css" href="css/jquery-ui.css">
<link rel="stylesheet" type="text/css" href="css/tryswift.css">
<script src="js/jquery.js" type="text/javascript"></script>
<script src="js/jquery-ui.js" type="text/javascript"></script>

<script>
	$(function() {
		$("#accordion").accordion({
			collapsible: true,
			heightStyle: "content",
		});
	});
</script>

</head>

<body>

<div id="tutorial">

  	<div id="header">
  		<h1>Welcome to Try Swift!</h1>
  	</div>

<div id="accordion">

<h2>Introduction</h2>
<div class="example">
	<p>
		This web interface lets you learn Swift from your browser - nothing to install.
	</p>


	<p>
		You can run the built-in example scripts, change them, and run your own scripts.
	</p>


	<ul>

		<li>select a code example from the drop-down "Example" menu above</li>
		<li>click &#91;Explain&#93; to view an explanation of the  example</li>
		<li>click [Execute] (below) to run the example</li>
		<li>click [File outputs] to view the output files produced by your script</li>
		<li>click [Reset] to restore the example to its initial state (LOSES YOUR CHANGES!)</li>

	</ul>


	<p>The example scripts are:</p>

	<ol type="i">

		<li><b>Hello World</b> - Shows the basic syntax for running an app to produce a file</li>
		<li><b>Foreach</b> - Introduces the foreach statement to run multiple apps in parallel</li>
		<li><b>Multiple apps</b> - Show dependencies between apps to specify a workflow</li>
		<li><b>Multi-stage</b> - Example of a larger multi-stage workflow</li>

	</ol>

	<p>To test your own script, enter some Swift code below, or in any other window</p>

	<p>TrySwift gives you a few built-in "apps" to run, as needed by each example.
        It executes on a pool of virtual machines, one VM per Swift run (at the moment).</p>

    <p>The Swift language is explained in the <a href="http://swift-lang.org/docs" target="_blank">Swift User Guide</a></p>

<!-- <div class="script">

<pre>tracef("Hello, World! This is my %s code!\n","Swift");</pre>

</div> -->


</div>

<h2>Hello world!</h2>
<div class="example">

	<p>Let's take a closer look at this script and go through it line by line.</p>
	<pre>type file;</pre>
	<p>Most Swift scripts will make extensive use of files. This line allows us to use the file datatype and will be the first line of most scripts.</p>
	<pre>app (file out) echo_app (string s)
{
    echo s stdout=filename(out);
} 
    </pre>
    <p>The code above defines an application. In this case, the app is the unix utility echo. Every app function can define an input and an output. Outputs are defined to the left of the app name (file o). Inputs are defined to the right of the app name (string s).</p>
    <pre>echo s stdout=filename(o);</pre>
    <p>The echo command by itself does not create any files. Instead, what we do in this example is redirect the output of the command to a file by using <pre>stdout=filename(o)</pre></p>
    <p>Now that our app function is defined, let's create a file and call echo.</p>
    <pre>
file out <"out.txt">;
out = echo("Hello world!");
	</pre>
	<p>Try running the program. When it is finished, you should see a file called out.txt get created that contains the text "Hello world!"</p>
	<h3>Exercises</h3>
	<ul>
		<li>Change the text from "Hello world!" to "Hello Swift!"</li>
		<li>Change the name of the output file</li>
	</ul>

</div>

<h2>Foreach</h2>
<div class="example">

   <p>In this example, we first change our application. Instead of using "echo", we use an app called simulate. The simulate application serves as a trivial proxy for any more complex scientific simulation application. In this example, simulate will print a single number in the range of 1-100.</p>

   <pre>app (file o) simulate_app ()
{
  simulate stdout=filename(o);
}</pre>

	<p>Swift is a simple scripting language for executing many instances of ordinary application programs on distributed parallel resources. Swift scripts run many copies of ordinary programs concurrently, using statements like this:</p>

	<pre>foreach i in [1:10] {
  string fname=strcat("output/sim_", i, ".out");
  file f ;
  f = simulate_app();
}</pre>

	<p>In this example the foreach loop will iterate over a range of numbers from 0 to 9. It will then map an output file and run the simulate app. The important thing to realize about this example is that every iteration will run in parallel (up to a user defined throttle).</p>

	<p>Another new feature in this example is the file mapper. In the first hello world example, we saw a simplified version of a file mapper with the line:</p>

	<pre>file out <"out.txt">;</pre>

	<p>This is the same as saying</p>

	<pre>file out <single_file_mapper; file="output.txt">;</pre>

	<p>Defining a file mapper in this way allows a file name to be the content of a string or the output of another function. The strcat function combines multiple strings into a single string.</p>

	<p>Execute the script and examine the results. You should see 10 files creates with random numbers.</p>

</div>

<h2>Multiple apps</h2>
<div class="example">
	<p>After all the parallel simulations in an ensemble run have completed, it is typically necessary to gather and analyze their results with some kind of post-processing analysis program or script. This script shows an example of this.</p>

	<p>The first change in this script is to the simulate script:</p>

	<pre>app (file o) simulate_app (int time)
{
  simulate "-t" time stdout=filename(o);
}</pre>

	<p>Simulate now takes an argument, time. The command "simulate -t 10" will sleep for 10 seconds before printing a value. This is an example of how to pass command line arguments to an app in Swift.</p>

	<p>We introduce a new app call called stats:</p>

	<pre>app (file o) stats_app (file s[])
{
  stats filenames(s) stdout=filename(o);
}</pre>

	<p>The stats app function takes an array of files as input (file s[]). The stats app takes a list of files, reads the numbers contained inside, and prints the average value. The filenames() function simply prints a list of all filenames contained within a file array.
	</p>

	<p>Within the foreach loop:</p>

	<pre>simout = simulate_app(time);
  sims[i] = simout;</pre>

  	<p>We now add each simout file to the sims array before finally passing all the files to stats</p>

  	<pre>foreach i in [1:nsims] {
  string fname = strcat("output/sim_",i,".out");
  file simout <single_file_mapper; file=fname>
  simout = simulate_app(time);
  sims[i] = simout;
}

file average <"output/average.out">
average = stats_app(sims);</pre>

	<p>Execute the script and view output/average.out to verify it succeeded.</p>

<h3>Exercises</h3>
	<ul>

       <li>Modify the simulate_app function so that it accepts a second int that will representing range (hint: multiple inputs are separated by commas).</li>

       <li>Modify the simulate command line arguments. The current arguments are "-t time". Simulate takes another command line option, -r. The -r option sets the range of random numbers it generates. Call simulate with the added options -r 1000.</li>

	</ul>

</div>

<h2>Multi-stage workflows</h2>
<div>
	
	<p>This example expands the workflow pattern of the previous example by adding additional stages to the workflow. Here, we generate a dynamic seed value that will be used by all of the simulations, and for each simulation, we run an pre-processing application to generate a unique "bias file". This pattern is shown below, followed by the Swift script.</p>

	<img src="scripts/005-multistage.png" style="display: block; margin-left: auto; margin-right: auto;"></img>

	<p>Note that the workflow is based on data flow dependencies: each simulation depends on the seed value, calculated in these two dependent statements:</p>

	<pre>seedfile = genseed_app(1);
int seedval = readData(seedfile);</pre>

	<p>The workflow also depends on the bias file, computed and then consumed in these two dependent statements:</p>

	<pre>biasfile = genbias_app(1000, 20);
(simout,simlog) = simulation_app(steps, range, biasfile, 1000000, values);</pre>

	<p>We produce 20 values in each bias file. Simulations of less than 20 values ignore the unneeded numbers, while simualtions of more than 20 will use the last bias number for all values past 20.</p>

<h3>Exercises</h3>
   <ul>

      <li>Adjust the code to produce the same number of bias values as is needed for each simulation.</li>

      <li>Modify the script to generate a unique seed value for each simulation</li>

   </ul>

</div>

</div>  <!-- accordion -->

</div>




</body>







</html>

























